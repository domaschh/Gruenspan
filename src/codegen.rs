use crate::parser::Func;
use anyhow::{bail, Result};
use chumsky::chain::Chain;
use std::collections::HashMap;

#[derive(Debug)]
struct LineOp {
    line_nr: usize,
    bop_type: Bop,
}

#[derive(Debug)]
enum BOPType {
    Number,
    Boolean,
    String,
}

#[derive(Debug)]
enum Bop {
    Local(usize),
    Store(usize),
    Load(usize),
    Const(usize),
    Add,
    Sub,
    Div,
    Mul,
    LowerT,
    GreaterT,
    Equal,
    NotEq,
    Call(String),
    Print,
    JumpTrue,
    JumpFalse,
}

#[derive(Debug)]
pub struct BFunc {
    name: String,
    ops: Vec<LineOp>,
    arg_ct: usize,
}

impl BFunc {
    fn new(name: String, ops: Vec<LineOp>, arg_ct: usize) -> Self {
        BFunc { name, ops, arg_ct }
    }
}

pub struct Generator {
    ast: HashMap<String, Func>,
}

impl Generator {
    pub fn new(ast: HashMap<String, Func>) -> Self {
        Generator { ast }
    }

    /// Takes the bastract syntax tree stored in the Generator and prints the generated bytecode
    pub fn generate_bytecod(&self) -> Result<Vec<BFunc>> {
        let mut bfuncs: Vec<BFunc> = Vec::with_capacity(self.ast.len());
        let Some(main_func) = self.ast.get("main") else {
            bail!("Can't find main functions");
        };
        println!("{:?}", main_func.body);
        println!("{:?}", main_func.body.len());

        let main_ops = Vec::new();
        bfuncs.push(BFunc::new("main".to_string(), main_ops, 0));

        Ok(Vec::new())
    }
}
