use crate::parser::{Expr, Func};
use anyhow::{bail, Result};
use chumsky::{chain::Chain, primitive::Container};
use std::collections::HashMap;

#[derive(Debug)]
struct RelativeOperation {
    line_nr: usize,
    bop_type: ByteCodeOp,
}

impl RelativeOperation {
    fn new(line_nr: usize, bop_type: ByteCodeOp) -> Self {
        RelativeOperation { line_nr, bop_type }
    }
}

#[derive(Debug)]
enum BOPType {
    Number,
    Boolean,
    String,
}

#[derive(Debug)]
enum ByteCodeOp {
    Local(usize),
    Store(usize),
    Load(usize),
    Const(usize),
    Add,
    Sub,
    Div,
    Mul,
    LowerT,
    GreaterT,
    Equal,
    NotEq,
    Call(String),
    Print,
    JumpTrue,
    JumpFalse,
}

#[derive(Debug)]
pub struct BFunc {
    name: String,
    ops: Vec<RelativeOperation>,
    arg_ct: usize,
}

impl BFunc {
    fn new(name: String, ops: Vec<RelativeOperation>, arg_ct: usize) -> Self {
        BFunc { name, ops, arg_ct }
    }
}

impl From<Expr> for Vec<RelativeOperation> {
    fn from(value: Expr) -> Self {
        Vec::new()
    }
}

impl From<&Func> for Vec<RelativeOperation> {
    fn from(function: &Func) -> Self {
        let mut operations = Vec::new();
        let mut var_map = HashMap::new();
        for (i, arg) in function.args.iter().enumerate() {
            operations.push(RelativeOperation::new(i, ByteCodeOp::Local(i)));
            var_map.insert(arg, i);
        }
        match &function.body.0 {
            Expr::Error => !unreachable!(),
            Expr::Value(_) => todo!(),
            Expr::List(_) => todo!(),
            Expr::Local(_) => todo!(),
            Expr::Let(a, b, c) => println!("Reaching amtch arm {:?} {:?} {:?}", a, b, 1),
            Expr::Then(_, _) => todo!(),
            Expr::Binary(_, _, _) => todo!(),
            Expr::Call(_, _) => todo!(),
            Expr::If(_, _, _) => todo!(),
            Expr::Print(_) => todo!(),
        }
        operations
    }
}

pub struct Generator {
    ast: HashMap<String, Func>,
}

impl Generator {
    pub fn new(ast: HashMap<String, Func>) -> Self {
        Generator { ast }
    }

    /// Takes the bastract syntax tree stored in the Generator and prints the generated bytecode
    pub fn generate_bytecod(&self) -> Result<Vec<BFunc>> {
        if self.ast.contains_key("main") {
            Ok(self
                .ast
                .iter()
                .map(|func_and_name| {
                    BFunc::new(
                        func_and_name.0.clone(),
                        func_and_name.1.into(),
                        func_and_name.1.args.len(),
                    )
                })
                .collect())
        } else {
            bail!("No main found")
        }
    }
}
